public class ListString {
    private static class StringItem {
        private final static int SIZE = 16;//размер символьного массива
        private char[] symbols;//символьный массив
        private StringItem next;//следующий узел списка
        private byte size;//заполненность символьного массива

        //конструктор по умолчанию
        public StringItem() {
            //1.next <- null
            //2.size <- 0
        }

        //конструктор узла из строки, длина которой <= SIZE, для конструктора ListString из String, добавления
        //используется только при преобразовании string к ListString => блоки еще будут полными(кроме,быть может,последнего)
        public StringItem(String str){
            //1.Преобразование строки к массиву с помощью вызова toCharArray().
                //Если пришел кусочек < 16, то
                    //создаю массив
                    //посимвольно копирую в него через charAt в цикле по длине str
            //3.next <- null
            //4.size <- длина str
        }

        //универсальный копирующий конструктор - создает копию, перенося символы, начиная со start и до end
        //параметр start используется для вырезки
        public StringItem(StringItem copied, int start, int end) {
            //1.Выделение памяти под массив
            //2.вызов метода, копирующего массив начиная со start и до end. Копирую в начало нового массива
            //3.next <- null
            //4.size <- end-start+1
        }

        //конструктор копирования если дублируется весь узел
        public StringItem(StringItem copied) {
            //вызов StringItem(copied,0,copied[size])
        }

        //private StringItem unionItem(){
            //1. Копирую второй массив в первый, начиная с его позиции [size] через arrayCopy(char[]copied, int start, int end)
            //2. В поле next первого помещаю next второго те исключаю второй блок из списка
        //}

        //private StringItem splitItem(int index){//индекс элемента массива, после которого происходит разрез
            //1. Создаю новый узел-копию текущего узла от index+1 до его size
            //2. size текущего <- index+1
            //3. next созданной в п.1 копии <- next текущего,  next текущего <- созданная копия
        // }

        public String toString(){
            String res = new String(symbols, 0, size);
            return res+'\n';
        }


        private static class Address{
            StringItem item;
            int index;

            //конструктор адреса по найденному узлу и индексу символа внутри него
            private Address(StringItem externalAddress, int internalAddress){}
        }

    }

    //------------------------------------------------------------//
    private StringItem head;

    //конструктор по умолчанию
    public ListString(){
        //head=null;
    }

    //конструктор копирования - используется для копирования параметров метода вставки(не можем вставлять объект-параметр, нужна его копия)
    public ListString(ListString list){
        //1. узнаем длину параметра list, если 0, то  возвращаю новый объект ListString, созданный через дефолтный конструктор, если длина не 0, то действия далее
        //2. завожу итератор, который будет бегать вместо head потому что он не может перемещаться
        //3. отдельно создаю копию head. В его next создаю новый узел(копирование)
        //4. итератор переместила на следующий, в его next так же создала новый узел(копирование)
        //5. для последнего узла next<-null
    }
    public ListString(String str){
        //1. проверяю на пустоту, если str пустая, то возвращаю новый объект ListString, созданный через дефолтный конструктор
        //1. узнаем количество целых блоков через length/SIZE. Если целых 0, то переходим к п.4
        //2. создаем head
        //3. в цикле делим строку на кусочки по SIZE:
            //в цикле перебираем начальный и конечный индексы метода String substring(int beginIndex, int endIndex) через 16
            // создаем новые блоки в next'e старого - конструктор от строки
        //4. оставшийся хвостик приводим к узлу отдельно, используя конструктор от строки
    }


    //--------------------/  методы  /-----------------------//

    //реальная длина строки
    public int length(){
        //1.Если isEmpty вернул ложь, то возвращаю 0
        //Действия далее над непустым списком:
        //2.Иду по всем узлам до последнего - EndOfString() (используя do while чтобы подсчитать длину списка из 1 узла)
        //3.Суммирование реальной длины символьных массивов - поле size
        //4.Уплотнение строки:
            // Начиная с первого узла,смотрю на следующий, пока сумма их реальных длинн <=SIZE вызоваю unionItem()
            // После выхода из цикла перехожу к следующему узлу - посмотрела поле next узла, на котором вышла
    }

    //вернуть символ в строке в позиции index
    public char charAt(int index){
        //1.(в блоке try) вызов вспомогательного метода distinationItem(int index) для получения нужного узла списка(внешнего адреса) и индекса внутри него(внутреннего адреса)
        //2.Возвращаю нужный символ внутри найденного целевого узла, если адресс действительный,
            //иначе (item==null & index==-1) выброс исключения StringException("invalid index")
    }

    //заменить в строке символ в позиции index на символ ch
    public void setCharAt(int index, char ch){
        //1.Вызов вспомогательного метода distinationItem(int index) для получения нужного узла списка(внешнего адреса) и индекса внутри него(внутреннего адреса)
        //2.Присваиваю нужному элементу внутри найденного целевого узла значение ch,  если адресс действительный,
            //иначе (item==null & index==-1) выброс исключения StringException("invalid index")
        // }
    }

    //взятие подстроки, от start до end, не включая end, возвращается новый объект ListString, исходный не изменяется
    public ListString substring(int start, int end) {
        //Если строка пустая - ???
        //1.С помощью distinationItem находим в каких узлах расположены элементы с номерами start и end
        //2.Проверяю start на действительность, если не ок те (item==null & index==-1) выброс исключения StringException("invalid index")
        //3.Проверка адреса end. Если ок, то идем до end, иначе до конца те end_index=(end<length)? end: length
        //4.Создаем новый экземпляр класса ListString
        //4а.Случай, когда start и end в одном блоке рассматривается отдельно - создаем 1 новый узел.
        //5.Создаем 2 узла через копирующий конструктор найденных в п.3 учитывая внутренний адрес - границы копирования.
        //Т.е первый копирую от start до size, последний от 0 до end
        //В head закидываем узел созданный от start.
        //6.Начиная со следующего узла (пока он не равен последнему) создаем узел,копируя полностью, закидываем в next новый объект StringItem
        //7.Связываю копии первого и последнего узла с куском между через поля next
        //На выходе новый экземпляр- вырезанный кусочек, изначальная строка не изменена
    }



    //добавить в конец строки символ (в конец символьного массива последнего блока, если там есть свободное место, иначе в начало символьного массива нового блока)
    public void append(char ch){
        //1. Нахожу последний узел через EndOfString().
        //      Если его в нем есть хотя бы 1 свободная ячейка, то вставляю символ в массив на позицию [size]
        //2. Если последний узел полностью заполнен:
                //в next'e последнего узла создаю новый
                //Инициализирую массив -  на позицию [0] нового массива закидываю нужный символ
                //next нового узла null
    }

    //добавить в конец строку ListString (перекинуть указатель на следующий последнего блока исходной строки на голову добавляемой строки)
    public void append(ListString string){
        //1.Делаем копию string, дальше работаем только с копией
        //2.Находим последний узел текущего списка(копии) EndOfString(), его next <- head копии
    }

    //добавить в конец строку String (перекинуть указатель на следующий последнего блока исходной строки на голову добавляемой строки)
    public void append(String string){
        //1. Преобразуем string в ListString
        //2. Находим последний узел текущего списка EndOfString(), его next <- head части, которую нужно добавить
    }

    //вставить в строку в позицию index строку ListString (разбить блок на два по позиции index и строку вставить между этими блоками)
    public void insert(int index, ListString string){
        //проверка на пустоту isEmpty() - ???    вызов append или исключение

        //1. создаю копию string, далее использую только ее
        //2. находим адрес по index(узел и внутренний адрес). Проверяю адрес на действительность
            //Если все ок, то см. дальше, иначе (item==null & index==-1) выброс исключения StringException("invalid index")
        //insertWithoutCheck(index, копия string)

    }

    //вставить в строку в позицию index строку String (разбить блок на два по позиции index и строку вставить между этими блоками)
    public void insert(int index, String string) {
        //проверка на пустоту isEmpty() - ???

        //1. преобразую string в ListString, далее действия, аналогичные методу выше
        //2. находим адрес по index(узел и внутренний адрес).  Проверяю адрес на действительность
        //Если все ок, то см. дальше, иначе (item==null & index==-1) выброс исключения StringException("invalid index")
        //insertWithoutCheck(index, преобразованный string)
    }

    private void insertWithoutCheck(int index, ListString str){
        //1. разбиваю узел splitItem(index)
        //2. в next последнего узла вставляемой части помещаю созданный при разбиении узел(вторую половинку разбиения)
        //3. в next исходного узла разбиения (первой половинки) помещаю  head части, которую необходимо вставить
    }


    //Строковое представление объекта ListString (переопределить метод)
    public String toString(){
        //1. Вызов length() для уплотнения
        //2. Создаю строку для результата
        //3. Иду по каждому узлу, пока не встречу последний прибавляю к результирующей строке каждый узел(toString переопределен для узла)
    }

    private StringItem.Address distinationItem(int index){
        //1.Если index<0? выбрасываю исключение StringException("invalid index")
        //1.Если список нулевой (isEmpty==true), то выбрасываю исключение StringException("Empty list"), иначе далее
            //2.Если первый узел является последним (head.next==null), то возвращаю null и  index(если index в head), иначе StringException("invalid index")
        //3.Завожу 2 итератора StringItem через дефолтный
        //4.Создание счетчика = 0 - глобальный номер текущего символа
        //5.Первый iter1=head.next , второй iter2=head
        //5.Пока iter1 не равен null
            //смотрю на size iter1 если (index - счетчик) меньше size
                //счетчик+=size
                //передвигаю итераторы iter2=iter1; iter1=iter1.next
            //условие выполнилось = нашли целевой узел

        //5.Как только первый нашел текущий узел, возвращаю второй.


        //1.Проверка index на действительность
            //Сравнение с length(), вызов метода также сократит число итераций следующего цикла.
            //если адрес не действительный(>length), возвращает новый объект Address item<-null, index<--1
        //Если ок, то
        //2.Создание счетчика = 0 - глобальный номер текущего символа
        //3.Иду по каждому узлу списка пока разница (index - счетчик) не станет меньше size текущего узла, счетчик+=size
        // условие выполнилось = нашли целевой узел
        //4.Возвращаю новый экземпляр класса Address(найденный индекс, index-счетчик)
    //}

    private StringItem.Address EndOfString() {
            //1.Если список нулевой (isEmpty==true), то выбрасываю исключение, иначе далее
            //2.Если первый узел является последним (head.next==null), то выбрасываю исключение, иначе далее
            //3.Завожу 2 итератора StringItem через дефолтный
            //4.Первый=head, второй= head.next
            //5.Пока второй не равен this,увеличиваю итераторы +1
            //5.Как только первый нашел текущий узел, возвращаю второй
        }

    private char[] arrayCopy(char[]copied, int start, int end){
        //1. Выделение памяти под новый массив char[] размера SIZE
        //2. В цикле от start до end посимвольно копирую старый массив в новый
    }

    private boolean isEmpty(){
        if (this.head==null)
            return true;
        return false;
    }

    private StringItem Previous(){
        //1.Если список нулевой (isEmpty==true), то выбрасываю исключение, иначе далее
        //2.Если первый узел является последним (head.next==null), то выбрасываю исключение, иначе далее
        //3.Завожу 2 итератора StringItem через дефолтный
        //4.Первый=head, второй= head.next
        //5.Пока второй не равен this,увеличиваю итераторы +1
        //5.Как только первый нашел текущий узел, возвращаю второй
    }
}

//нужен ли в копировании массива параметр в какую позицию массива копировать - используется в unionItem()
//нужен ли метод возвращающий предыдущий узел - псевдо двусвязный список - используется в splitItem()
//метод для проверки списка на пустоту - есть

//что делать если вырезаем из пустой строки
//

